//----------------------------------*-C++-*----------------------------------//
// Copyright 2024 UT-Battelle, LLC, and other Celeritas developers.
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: (Apache-2.0 OR MIT)
//---------------------------------------------------------------------------//
//! \file celeritas/optical/ScintillationPreGenerator.hh
//---------------------------------------------------------------------------//
#pragma once

#include "corecel/Assert.hh"
#include "corecel/Macros.hh"
#include "celeritas/Quantities.hh"
#include "celeritas/phys/ParticleTrackView.hh"
#include "celeritas/random/distribution/NormalDistribution.hh"
#include "celeritas/random/distribution/PoissonDistribution.hh"
#include "celeritas/track/SimTrackView.hh"

#include "OpticalDistributionData.hh"
#include "OpticalPropertyData.hh"
#include "ScintillationData.hh"

namespace celeritas
{
//---------------------------------------------------------------------------//
/*!
 * Sample the number of Scintillation photons to be generated by
 * \c ScintillationGenerator and populate \c OpticalDistributionData values
 * using Param and State data.
 */
class ScintillationPreGenerator
{
  public:
    // Placeholder for data that is not available through Views

    struct OpticalPreGenStepData
    {
        real_type time{};  //!< Pre-step time
        units::MevEnergy energy_dep;  //!< Step energy deposition
        EnumArray<StepPoint, OpticalStepData> points;  //!< Pre- and post-steps

        //! Check whether the data are assigned
        explicit CELER_FUNCTION operator bool() const
        {
            return energy_dep > zero_quantity()
                   && points[StepPoint::pre].speed > zero_quantity();
        }
    };

    // Construct with optical properties, scintillation, and step data
    inline CELER_FUNCTION
    ScintillationPreGenerator(ParticleTrackView const& particle_view,
                              SimTrackView const& sim_view,
                              OpticalMaterialId material,
                              NativeCRef<ScintillationData> const& shared,
                              OpticalPreGenStepData const& step_data);

    // Populate an optical distribution data for the Scintillation Generator
    template<class Generator>
    inline CELER_FUNCTION OpticalDistributionData operator()(Generator& rng);

  private:
    ParticleTrackView const& particle_view_;
    real_type step_len_;
    OpticalMaterialId mat_id_;
    NativeCRef<ScintillationData> const& shared_;
    OpticalPreGenStepData step_;
};

//---------------------------------------------------------------------------//
// INLINE DEFINITIONS
//---------------------------------------------------------------------------//
/*!
 * Construct with input parameters.
 */
inline CELER_FUNCTION ScintillationPreGenerator::ScintillationPreGenerator(
    ParticleTrackView const& particle_view,
    SimTrackView const& sim_view,
    OpticalMaterialId material,
    NativeCRef<ScintillationData> const& shared,
    OpticalPreGenStepData const& step_data)
    : particle_view_(particle_view)
    , step_len_(sim_view.step_length())
    , mat_id_(material)
    , shared_(shared)
    , step_(step_data)
{
    CELER_EXPECT(step_len_);
    CELER_EXPECT(mat_id_);
    CELER_EXPECT(shared_);
    CELER_EXPECT(step_);
}

//---------------------------------------------------------------------------//
/*!
 * Return an \c OpticalDistributionData object. If no photons are sampled, an
 * empty object is returned and can be verified via its own operator bool.
 */
template<class Generator>
inline CELER_FUNCTION OpticalDistributionData
ScintillationPreGenerator::operator()(Generator& rng)
{
    auto const& spectrum
        = shared_.particle_spectra[particle_view_.particle_id()]
              .components[mat_id_];
    CELER_EXPECT(spectrum);

    // TODO: Use visible energy deposition when Birks quenching is available
    real_type mean_num_photons = spectrum.yield * step_.energy_dep.value();

    OpticalDistributionData result;
    if (mean_num_photons > 10)
    {
        real_type sigma = spectrum.resolution_scale
                          * std::sqrt(mean_num_photons);
        result.num_photons
            = NormalDistribution<real_type>(mean_num_photons, sigma)(rng)
              + real_type{0.5};  // WHY?
    }
    else
    {
        result.num_photons
            = PoissonDistribution<real_type>(mean_num_photons)(rng);
    }

    if (result.num_photons > 0)
    {
        // Assign remaining data
        result.charge = particle_view_.charge();
        result.material = mat_id_;
        result.step_length = step_len_;
        result.time = step_.time;
        result.points = step_.points;
    }
    return result;
}

//---------------------------------------------------------------------------//
}  // namespace celeritas
