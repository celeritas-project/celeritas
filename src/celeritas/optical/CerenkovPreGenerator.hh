//----------------------------------*-C++-*----------------------------------//
// Copyright 2024 UT-Battelle, LLC, and other Celeritas developers.
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: (Apache-2.0 OR MIT)
//---------------------------------------------------------------------------//
//! \file celeritas/optical/CerenkovPreGenerator.hh
//---------------------------------------------------------------------------//
#pragma once

#include "corecel/Assert.hh"
#include "corecel/Macros.hh"
#include "corecel/data/StackAllocator.hh"
#include "celeritas/phys/ParticleTrackView.hh"
#include "celeritas/random/distribution/PoissonDistribution.hh"
#include "celeritas/track/SimTrackView.hh"

#include "CerenkovData.hh"
#include "CerenkovDndxCalculator.hh"
#include "OpticalDistributionData.hh"
#include "OpticalGenData.hh"
#include "OpticalPropertyData.hh"

namespace celeritas
{
//---------------------------------------------------------------------------//
/*!
 * Sample the number of Cerenkov photons to be generated by
 * \c CerenkovGenerator and populate \c OpticalDistributionData values using
 * Param and State data.
 * \code
    OpticalPreStepData step_data;
    // Populate step_data

   CerenkovPreGenerator pre_generate(particle,
                                     sim,
                                     position,
                                     material_id,
                                     properties->host_ref(),
                                     params->host_ref(),
                                     step_data
                                     allocate);

    auto optical_dist_data = pre_generate(rng);
    if (optical_dist_data)
    {
        CerenkovGenerator cerenkov_generate(... , optical_dist_data, ...);
        cerenkov_generate(rng);
    }
 * \endcode
 */
class CerenkovPreGenerator
{
  public:
    //!@{
    //! \name Type aliases
    using DistributionAllocator = StackAllocator<OpticalDistributionData>;
    //!@}

  public:
    // Construct with optical properties, Cerenkov, and step data
    inline CELER_FUNCTION
    CerenkovPreGenerator(ParticleTrackView const& particle,
                         SimTrackView const& sim,
                         Real3 const& pos,
                         OpticalMaterialId mat_id,
                         NativeCRef<OpticalPropertyData> const& properties,
                         NativeCRef<CerenkovData> const& shared,
                         OpticalPreStepData const& step_data,
                         DistributionAllocator& allocate);

    // Populate optical distribution data for the Cerenkov Generator
    template<class Generator>
    inline CELER_FUNCTION size_type operator()(Generator& rng);

  private:
    units::ElementaryCharge charge_;
    real_type step_len_;
    real_type time_;
    OpticalMaterialId mat_id_;
    EnumArray<StepPoint, OpticalStepData> points_;
    DistributionAllocator& allocate_;
    real_type num_photons_per_len_;
};

//---------------------------------------------------------------------------//
// INLINE DEFINITIONS
//---------------------------------------------------------------------------//

//---------------------------------------------------------------------------//
/*!
 * Construct with optical properties, Cerenkov, and step information.
 */
CELER_FUNCTION CerenkovPreGenerator::CerenkovPreGenerator(
    ParticleTrackView const& particle,
    SimTrackView const& sim,
    Real3 const& pos,
    OpticalMaterialId mat_id,
    NativeCRef<OpticalPropertyData> const& properties,
    NativeCRef<CerenkovData> const& shared,
    OpticalPreStepData const& step_data,
    DistributionAllocator& allocate)
    : charge_(particle.charge())
    , step_len_(sim.step_length())
    , time_(step_data.time)
    , mat_id_(mat_id)
    , allocate_(allocate)
{
    CELER_EXPECT(charge_ != zero_quantity());
    CELER_EXPECT(step_len_ > 0);
    CELER_EXPECT(mat_id_);
    CELER_EXPECT(step_data);

    points_[StepPoint::pre].speed = step_data.speed;
    points_[StepPoint::pre].pos = step_data.pos;
    points_[StepPoint::post].speed = particle.speed();
    points_[StepPoint::post].pos = pos;

    units::LightSpeed beta(real_type{0.5}
                           * (points_[StepPoint::pre].speed.value()
                              + points_[StepPoint::post].speed.value()));

    CerenkovDndxCalculator calculate_dndx(properties, shared, mat_id_, charge_);
    num_photons_per_len_ = calculate_dndx(beta);
}

//---------------------------------------------------------------------------//
/*!
 * Sample number of photons to generate and create optical distribution data.
 *
 * Returns the number of photons, which is sampled from a Poisson distribution
 * with a mean
 * \f[
   \langle n \rangle = \ell_\text{step} \frac{dN}{dx}
 * \f]
 * where \f$ \ell_\text{step} \f$ is the step length.
 */
template<class Generator>
CELER_FUNCTION size_type CerenkovPreGenerator::operator()(Generator& rng)
{
    if (num_photons_per_len_ == 0)
    {
        return 0;
    }

    // TODO: handle failure to allocate space?
    OpticalDistributionData* data = allocate_(1);
    CELER_ASSERT(data);
    data->num_photons = PoissonDistribution<real_type>(num_photons_per_len_
                                                       * step_len_)(rng);
    if (data->num_photons > 0)
    {
        data->time = time_;
        data->step_length = step_len_;
        data->charge = charge_;
        data->material = mat_id_;
        data->points = points_;
    }
    return data->num_photons;
}

//---------------------------------------------------------------------------//
}  // namespace celeritas
