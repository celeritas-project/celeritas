//----------------------------------*-C++-*----------------------------------//
// SPDX-FileCopyrightText: 2020 CERN
// SPDX-License-Identifier: Apache-2.0
//---------------------------------------------------------------------------//
/*!
 * \file GeantGeometryImporter.hh
 * \brief Class to create a VecGeom model from a pre-existing Geant4 geometry
 *
 * Original code from G4VecGeomNav package by John Apostolakis et.al.
 *
 * Original source:
 * https://gitlab.cern.ch/VecGeom/g4vecgeomnav/-/raw/fdd310842fa71c58b3d99646159ef1993a0366b0/include/G4VecGeomConverter.h
 */
//---------------------------------------------------------------------------//
#pragma once

#include <map>
#include <utility>
#include <vector>
#include <G4PVReplica.hh>
#include <G4RotationMatrix.hh>
#include <G4ThreeVector.hh>
#include <VecGeom/base/TypeMap.h>
#include <VecGeom/management/GeoManager.h>

class G4LogicalVolume;
class G4AffineTransformation;
class G4VPhysicalVolume;
class G4VSolid;

namespace celeritas
{

// class converting G4 to VecGeom (only geometry; no materials)
using vecgeom::BidirectionalTypeMap;
using vecgeom::LogicalVolume;
using vecgeom::Transformation3D;
using vecgeom::VPlacedVolume;
using vecgeom::VUnplacedVolume;

class GeantGeometryImporter
{
  private:
    /** Remember pointer to generated world from imported G4 geometry. */
    VPlacedVolume const* world_;

    // one G4 physical volume can correspond to multiple vecgeom placed volumes
    // (in case of replicas)
    std::map<G4VPhysicalVolume const*, std::vector<VPlacedVolume const*> const*>
        placed_volume_map_;

    std::map<G4VSolid const*, VUnplacedVolume const*> unplaced_volume_map_;

    std::map<G4LogicalVolume const*, LogicalVolume const*> logical_volume_map_;

    // fast O(1) lookup to get VecGeom or G4 placed volume based on index
    // FastG4VecGeomLookup fFastG4VGLookup;
    std::vector<Transformation3D const*> replica_transformations_;

    int verbose_;

  public:
    void set_verbose(int const verbose) { verbose_ = verbose; }
    int get_verbose_level() const { return verbose_; }

    /// Get placed volume that corresponds to a G4VPhysicalVolume
    std::vector<VPlacedVolume const*> const*
    get_placed_volume(G4VPhysicalVolume const* n) const
    {
        if (n == nullptr)
            return nullptr;
        // return (GeoManager::Instance().Convert(placed_volume_map_[n]));
        if (auto found = placed_volume_map_.find(n);
            found != placed_volume_map_.end())
            return found->second;
        else
            return nullptr;
    }

    /**
     * Queries the G4 geometry for the top volume and recursively
     * imports and converts to VecGeom geometry.
     */
    void convert_G4_geometry(G4VPhysicalVolume const*);

  private:
    /**
     * @brief Deletes all VecGeom geometry generated by this class.
     */
    void clear_vecgeom();

    /** @brief Converts a physical volume into a VecGeom placed volume.
     * Its transformation matrix and its logical volume are also converted,
     * making the conversion process recursive, comprising the whole geometry
     * starting from the top volume.
     * Will take care not to convert anything twice by checking the
     * mapping between Geant4 and VecGeom geometry.
     */
    std::vector<VPlacedVolume const*> const* convert(G4VPhysicalVolume const*);

    /**
     * @brief Special treatment needed for replicated volumes.
     */
    void extract_replicated_transformations(
        G4PVReplica const&, std::vector<Transformation3D const*>&) const;

    /**
     * @brief Converts G4 solids into VecGeom unplaced volumes
     */
    VUnplacedVolume* convert(G4VSolid const*);

    /**
     * @brief Converts logical volumes from Geant4 into VecGeom.
     * All daughters' physical volumes will be recursively converted.
     */
    LogicalVolume* convert(G4LogicalVolume const*);

    /**
     * @brief Converts transformation matrices
     */
    Transformation3D* convert(G4ThreeVector const&, G4RotationMatrix const*);

  public:
    // constructor
    GeantGeometryImporter()
        : world_(nullptr)
        , placed_volume_map_()
        , unplaced_volume_map_()
        , logical_volume_map_()
        , replica_transformations_()
        , verbose_(0)
    {
    }

    // destructor
    ~GeantGeometryImporter()
    {
        //..  The VecGeom geometry created during conversion is not owned here!
        // this->clear_vecgeom();
    }

  private:
    GeantGeometryImporter(GeantGeometryImporter const&) = delete;
    GeantGeometryImporter& operator=(GeantGeometryImporter const&) = delete;
};
}  // namespace celeritas
