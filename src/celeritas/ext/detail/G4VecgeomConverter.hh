//----------------------------------*-C++-*----------------------------------//
// SPDX-FileCopyrightText: 2020 CERN
// SPDX-License-Identifier: Apache-2.0
//---------------------------------------------------------------------------//
/*!
 * \file G4VecgeomConverter.hh
 * \brief Class to create a VecGeom model from a pre-existing Geant4 geometry
 *
 * Original code from G4VecGeomNav package by John Apostolakis et.al.
 *
 * Original source:
 * https://gitlab.cern.ch/VecGeom/g4vecgeomnav/-/raw/fdd310842fa71c58b3d99646159ef1993a0366b0/include/G4VecGeomConverter.h
 */
//---------------------------------------------------------------------------//
#pragma once

#include <utility>
#include <vector>
#include <G4PVReplica.hh>
#include <G4RotationMatrix.hh>
#include <G4ThreeVector.hh>
#include <VecGeom/base/TypeMap.h>
#include <VecGeom/management/GeoManager.h>

class G4LogicalVolume;
class G4AffineTransformation;
class G4VPhysicalVolume;
class G4VSolid;

namespace celeritas
{

// class converting G4 to VecGeom (only geometry; no materials)
using vecgeom::BidirectionalTypeMap;
using vecgeom::LogicalVolume;
using vecgeom::Transformation3D;
using vecgeom::VPlacedVolume;
using vecgeom::VUnplacedVolume;

class G4VecGeomConverter
{
  private:
    /** Remember pointer to generated world from imported G4 geometry. */
    VPlacedVolume const* world_;

    // one G4 physical volume can correspond to multiple vecgeom placed volumes
    // (in case of replicas)
    BidirectionalTypeMap<std::vector<VPlacedVolume const*> const*,
                         G4VPhysicalVolume const*>
        placed_volume_map_;

    BidirectionalTypeMap<VUnplacedVolume const*, G4VSolid const*>
        unplaced_volume_map_;

    BidirectionalTypeMap<LogicalVolume const*, G4LogicalVolume const*>
        logical_volume_map_;

    // fast O(1) lookup to get VecGeom or G4 placed volume based on index
    // FastG4VecGeomLookup fFastG4VGLookup;
    std::vector<Transformation3D const*> fReplicaTransformations;

    int verbose_;

  public:
    void SetVerbose(int const verbose) { verbose_ = verbose; }
    int GetVerboseLevel() const { return verbose_; }

    /// Get placed volume that corresponds to a G4VPhysicalVolume
    std::vector<VPlacedVolume const*> const*
    GetPlacedVolume(G4VPhysicalVolume const* n) const
    {
        if (n == nullptr)
            return nullptr;
        // return (GeoManager::Instance().Convert(placed_volume_map_[n]));
        assert(false);
        return nullptr;
    }

    /**
     * Queries the G4 geometry for the top volume and recursively
     * imports and converts to VecGeom geometry.
     */
    void ConvertG4Geometry(G4VPhysicalVolume const*);

  private:
    /**
     * @brief Deletes all VecGeom geometry generated by this class.
     */
    void Clear();

    /** @brief Converts a physical volume into a VecGeom placed volume.
     * Its transformation matrix and its logical volume are also converted,
     * making the conversion process recursive, comprising the whole geometry
     * starting from the top volume.
     * Will take care not to convert anything twice by checking the
     * bidirectional map between Geant4 and VecGeom geometry.
     */
    std::vector<VPlacedVolume const*> const* Convert(G4VPhysicalVolume const*);

    /**
     * @brief Special treatment needed for replicated volumes.
     */
    void ExtractReplicatedTransformations(
        G4PVReplica const&, std::vector<Transformation3D const*>&) const;

    /**
     * @brief Converts G4 solids into VecGeom unplaced volumes
     */
    VUnplacedVolume* Convert(G4VSolid const*);

    /**
     * @brief Converts logical volumes from Geant4 into VecGeom.
     * All daughters' physical volumes will be recursively converted.
     */
    LogicalVolume* Convert(G4LogicalVolume const*);

    /**
     * @brief Converts transformation matrices
     */
    Transformation3D* Convert(G4ThreeVector const&, G4RotationMatrix const*);

  public:
    // constructor
    G4VecGeomConverter()
        : world_(nullptr)
        , placed_volume_map_()
        , unplaced_volume_map_()
        , logical_volume_map_()
        , /*transformation_map_(),*/ verbose_(0)
    {
    }

    // destructor
    ~G4VecGeomConverter()
    {
        // this->Clear();
        //  the VecGeom geometry created during conversion is not owned here!
    }

  private:
    G4VecGeomConverter(G4VecGeomConverter const&)            = delete;
    G4VecGeomConverter& operator=(G4VecGeomConverter const&) = delete;
};
} // namespace celeritas
