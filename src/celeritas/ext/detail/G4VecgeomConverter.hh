//----------------------------------*-C++-*----------------------------------//
// SPDX-FileCopyrightText: 2020 CERN
// SPDX-License-Identifier: Apache-2.0
//---------------------------------------------------------------------------//
/*!
 * \file G4VecgeomConverter.hh
 * \brief Class to create a VecGeom model from a pre-existing Geant4 geometry
 *
 * Original code from G4VecGeomNav package by John Apostolakis et.al.
 *
 * Original source:
 * https://gitlab.cern.ch/VecGeom/g4vecgeomnav/-/raw/fdd310842fa71c58b3d99646159ef1993a0366b0/include/G4VecGeomConverter.h
 */
//---------------------------------------------------------------------------//
#pragma once

#include <utility>
#include <vector>
#include <VecGeom/base/TypeMap.h>
#include <VecGeom/management/GeoManager.h>

#include "Geant4/G4PVReplica.hh"
#include "Geant4/G4RotationMatrix.hh"
#include "Geant4/G4ThreeVector.hh"

class G4LogicalVolume;
class G4AffineTransformation;
class G4VPhysicalVolume;
class G4VSolid;

namespace celeritas
{
inline namespace VECGEOM_IMPL_NAMESPACE
{
class LogicalVolume;
class Transformation3D;
class UnplacedBox;
class VUnplacedVolume;
class VPlacedVolume;

} // namespace VECGEOM_IMPL_NAMESPACE
} // namespace vecgeom

// class converting G4 to VecGeom (only geometry; no materials)
class G4VecGeomConverter
{
  private:
    /** Remember pointer to generated world from imported G4 geometry. */
    vecgeom::VPlacedVolume const* fWorld;

    // vecgeom::BidirectionalTypeMap<unsigned int, G4VPhysicalVolume const*>
    // fPlacedVolumeMap; using G4PVReplicaPair = std::pair<G4VPhysicalVolume
    // const*, int>; vecgeom::BidirectionalTypeMap<unsigned int,
    // G4PVReplicaPair> fPlacedVolumeMap;

    // one G4 physical volume can correspond to multiple vecgeom placed volumes
    // (in case of replicas)
    vecgeom::BidirectionalTypeMap<std::vector<vecgeom::VPlacedVolume const*> const*,
                                  G4VPhysicalVolume const*>
        fPlacedVolumeMap;

    vecgeom::BidirectionalTypeMap<vecgeom::VUnplacedVolume const*, G4VSolid const*>
        fUnplacedVolumeMap;
    vecgeom::BidirectionalTypeMap<vecgeom::LogicalVolume const*,
                                  G4LogicalVolume const*>
        fLogicalVolumeMap;

    // fast O(1) lookup to get VecGeom or G4 placed volume based on index
    // FastG4VecGeomLookup fFastG4VGLookup;
    std::vector<vecgeom::Transformation3D const*> fReplicaTransformations;

    int fVerbose;

  public:
    /// Access singleton instance.
    static G4VecGeomConverter& Instance()
    {
        static G4VecGeomConverter instance;
        return instance;
    }

    vecgeom::VPlacedVolume const* world() const { return fWorld; }
    int                           GetVerboseLevel() const { return fVerbose; }

    // TGeoNode const *tgeonode(VPlacedVolume const *p) const
    // {
    //   if (p == nullptr) return nullptr;
    //   return fTGeoNodeVector[p->id()];
    // }

    // lookup the placed volume corresponding to a G4VPhysicalVolume
    vecgeom::VPlacedVolume const* Lookup(G4VPhysicalVolume const* node) const;

    /// Get placed volume that corresponds to a G4VPhysicalVolume
    std::vector<vecgeom::VPlacedVolume const*> const*
    GetPlacedVolume(G4VPhysicalVolume const* n) const
    {
        if (n == nullptr)
            return nullptr;
        // return (GeoManager::Instance().Convert(fPlacedVolumeMap[n]));
        assert(false);
        return nullptr;
    }

    void PrintNodeTable() const;

    void SetVerbose(const int verbose) { fVerbose = verbose; }

    /**
     * Queries the G4 geometry for the top volume and recursively
     * imports and converts to VecGeom geometry.
     */
    void ConvertG4Geometry(G4VPhysicalVolume const*);

    /**
     * @brief Deletes all VecGeom geometry generated by this class.
     */
    void Clear();

    /// Converts a TGeoNode to a VPlacedVolume, recursively converting
    /// daughters. Will take care not to convert anything twice by checking the
    /// bidirectional map between ROOT and VecGeom geometry.
    std::vector<vecgeom::VPlacedVolume const*> const*
    Convert(G4VPhysicalVolume const*);

    void ExtractReplicatedTransformations(
        G4PVReplica const&,
        std::vector<vecgeom::Transformation3D const*>&) const;

    vecgeom::VUnplacedVolume* Convert(G4VSolid const*);
    vecgeom::LogicalVolume*   Convert(G4LogicalVolume const*);
    vecgeom::Transformation3D*
    Convert(G4ThreeVector const&, G4RotationMatrix const*);

  private:
    G4VecGeomConverter()
        : fWorld(nullptr)
        , fPlacedVolumeMap()
        , fUnplacedVolumeMap()
        , fLogicalVolumeMap()
        ,
        /*fTransformationMap(),*/ fVerbose(0)
    {
    }
    G4VecGeomConverter(G4VecGeomConverter const&)            = delete;
    G4VecGeomConverter& operator=(G4VecGeomConverter const&) = delete;
};
