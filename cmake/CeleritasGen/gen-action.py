#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2021-2023 UT-Battelle, LLC, and other Celeritas developers.
# See the top-level COPYRIGHT file for details.
# SPDX-License-Identifier: (Apache-2.0 OR MIT)
"""
Tool to generate simpled "Action"-based kernel implementations automatically.
"""

import sys
from pathlib import Path
from launchbounds import make_launch_bounds

CLIKE_TOP = '''\
//{modeline:-^75s}//
// Copyright 2022-2023 UT-Battelle, LLC, and other Celeritas developers.
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: (Apache-2.0 OR MIT)
//---------------------------------------------------------------------------//
//! \\file {filename}
//! \\note Auto-generated by {script}: DO NOT MODIFY!
//---------------------------------------------------------------------------//
'''

HH_TEMPLATE = CLIKE_TOP + """\
#pragma once

#include "corecel/Assert.hh"
#include "corecel/Macros.hh"
#include "celeritas/global/ActionInterface.hh"

namespace celeritas
{{
namespace generated
{{
//---------------------------------------------------------------------------//
class {clsname} final : public ExplicitActionInterface, public ConcreteAction
{{
public:
  // Construct with ID and label
  using ConcreteAction::ConcreteAction;

  // Launch kernel with host data
  void execute(CoreParams const&, CoreStateHost&) const final;

  // Launch kernel with device data
  void execute(CoreParams const&, CoreStateDevice&) const final;

  //! Dependency ordering of the action
  ActionOrder order() const final {{ return ActionOrder::{actionorder}; }}
}};

#if !CELER_USE_DEVICE
inline void {clsname}::execute(CoreParams const&, CoreStateDevice&) const
{{
    CELER_NOT_CONFIGURED("CUDA OR HIP");
}}
#endif

//---------------------------------------------------------------------------//
}}  // namespace generated
}}  // namespace celeritas
"""

CC_TEMPLATE = CLIKE_TOP + """\
#include "{clsname}.hh"

#include <utility>

#include "corecel/Types.hh"
#include "celeritas/global/ExecuteAction.hh"
#include "celeritas/global/TrackLauncher.hh"
#include "../detail/{clsname}Impl.hh" // IWYU pragma: associated

namespace celeritas
{{
namespace generated
{{
//---------------------------------------------------------------------------//
/*!
 * Launch the {func} action on host.
 */
void {clsname}::execute(CoreParams const& params, CoreStateHost& state) const
{{
    return ::celeritas::execute_action(
        *this, params, state,
        TrackLauncher{{*params.ptr<MemSpace::native>(), *state.ptr(),
                      detail::{func}_track}});
}}

//---------------------------------------------------------------------------//
}}  // namespace generated
}}  // namespace celeritas
"""

CU_TEMPLATE = CLIKE_TOP + """\
#include "{clsname}.hh"

#include "corecel/device_runtime_api.h"
#include "corecel/Assert.hh"
#include "corecel/Types.hh"
#include "corecel/sys/KernelParamCalculator.device.hh"
#include "corecel/sys/Device.hh"
#include "celeritas/global/CoreParams.hh"
#include "celeritas/global/CoreState.hh"
#include "celeritas/global/TrackLauncher.hh"
#include "../detail/{clsname}Impl.hh"

namespace celeritas
{{
namespace generated
{{
namespace
{{
__global__ void{launch_bounds}{func}_kernel(
    CRefPtr<CoreParamsData, MemSpace::device> const params,
    RefPtr<CoreStateData, MemSpace::device> const state
)
{{
    TrackLauncher launch{{*params, *state, detail::{func}_track}};
    launch(KernelParamCalculator::thread_id());
}}
}}  // namespace

void {clsname}::execute(CoreParams const& params, CoreStateDevice& state) const
{{
    CELER_LAUNCH_KERNEL({func},
                        celeritas::device().default_block_size(),
                        state.size(),
                        params.ptr<MemSpace::native>(),
                        state.ptr());
}}

}}  // namespace generated
}}  // namespace celeritas
"""

SORTED_CU_TEMPLATE = CLIKE_TOP + """\
#include "{clsname}.hh"

#include "corecel/device_runtime_api.h"
#include "corecel/Assert.hh"
#include "corecel/Types.hh"
#include "corecel/sys/KernelParamCalculator.device.hh"
#include "corecel/sys/Device.hh"
#include "celeritas/global/CoreParams.hh"
#include "celeritas/global/CoreState.hh"
#include "celeritas/global/KernelLaunchUtils.hh"
#include "celeritas/global/TrackLauncher.hh"
#include "../detail/{clsname}Impl.hh"

namespace celeritas
{{
namespace generated
{{
namespace
{{
__global__ void{launch_bounds}{func}_kernel(
    CRefPtr<CoreParamsData, MemSpace::device> const params,
    RefPtr<CoreStateData, MemSpace::device> const state,
    ThreadId const offset
)
{{
    TrackLauncher launch{{*params, *state, detail::{func}_track}};
    launch(KernelParamCalculator::thread_id() + offset.get());
}}
}}  // namespace

void {clsname}::execute(CoreParams const& params, CoreStateDevice& state) const
{{
    KernelLaunchParams kernel_params = compute_launch_params(this->action_id(),
                                                             params,
                                                             state,
                                                             TrackOrder::{track_order});
    CELER_LAUNCH_KERNEL({func},
                        celeritas::device().default_block_size(),
                        kernel_params.num_threads,
                        params.ptr<MemSpace::native>(),
                        state.ptr(),
                        kernel_params.threads_offset);
}}

}}  // namespace generated
}}  // namespace celeritas
"""

TEMPLATES = {
    'hh': HH_TEMPLATE,
    'cc': CC_TEMPLATE,
    'cu': CU_TEMPLATE,
    'sorted.cu': SORTED_CU_TEMPLATE, 
}
LANG = {
    'hh': "C++",
    'cc': "C++",
    'cu': "CUDA",
    'sorted.cu': "CUDA",
}

def generate(**subs):
    ext = subs['ext']
    subs['modeline'] = "-*-{}-*-".format(LANG[ext])
    template = TEMPLATES[ext]
    subs['ext'] = ext.split('.')[-1]
    script = Path(sys.argv[0])
    filename = Path("{basename}.{ext}".format(**subs))
    subs['filename'] = Path(subs['basedir']) / filename
    subs['script'] = script.name
    subs['launch_bounds'] = make_launch_bounds(subs['func'])
    with open(filename, 'w') as f:
        f.write(template.format(**subs))

def main():
    import argparse
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        '--basedir',
        default='celeritas',
        help='execution path relative to src/')
    parser.add_argument(
        '--basename',
        help='File name (without extension) of output')
    parser.add_argument(
        '--class', dest='clsname',
        help='CamelCase name of the class prefix')
    parser.add_argument(
        '--func',
        help='snake_case name of the function')
    parser.add_argument(
        '--actionorder',
        help='Inter-kernel dependency order')
    parser.add_argument(
        '--compute-kernel-params',
        action='store_true',
        help='Adjuste grid size tracks are sorted by provided track-order')
    parser.add_argument(
        '--track-order',
        help='Expected track order')

    kwargs = vars(parser.parse_args())
    cu_ext = 'sorted.cu' if kwargs['compute_kernel_params'] else 'cu'
    for ext in ['hh', 'cc', cu_ext]:
        generate(ext=ext, **kwargs)

if __name__ == '__main__':
    main()
